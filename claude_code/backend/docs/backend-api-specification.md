# Ïã¨Ïû•ÏßàÌôò Í≤ÄÏÇ¨ ÏãúÏä§ÌÖú - Î∞±ÏóîÎìú ÏÑ§Í≥Ñ Î™ÖÏÑ∏ÏÑú

## üìã Î™©Ï∞®

1. [Í∞úÏöî](#Í∞úÏöî)
2. [Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïä§ÌÇ§Îßà ÏÑ§Í≥Ñ](#Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§-Ïä§ÌÇ§Îßà-ÏÑ§Í≥Ñ)
3. [ÌÅ¥ÎûòÏä§ ÏïÑÌÇ§ÌÖçÏ≤ò ÏÑ§Í≥Ñ](#ÌÅ¥ÎûòÏä§-ÏïÑÌÇ§ÌÖçÏ≤ò-ÏÑ§Í≥Ñ)
4. [Î©îÏÜåÎìú ÏïåÍ≥†Î¶¨Ï¶ò ÏÑ§Í≥Ñ](#Î©îÏÜåÎìú-ÏïåÍ≥†Î¶¨Ï¶ò-ÏÑ§Í≥Ñ)
5. [API ÏÑ§Í≥Ñ](#api-ÏÑ§Í≥Ñ)
6. [Î≥¥Ïïà ÏÑ§Í≥Ñ](#Î≥¥Ïïà-ÏÑ§Í≥Ñ)
7. [ÌôïÏû•ÏÑ± Í≥†Î†§ÏÇ¨Ìï≠](#ÌôïÏû•ÏÑ±-Í≥†Î†§ÏÇ¨Ìï≠)

## Í∞úÏöî

### ÏãúÏä§ÌÖú Î™©Ï†Å
CBNU Ïã¨Ïû•ÏßàÌôò Í≤ÄÏÇ¨ ÏãúÏä§ÌÖúÏùò Î∞±ÏóîÎìúÎäî ÏùòÎ£å Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨, ÏÇ¨Ïö©Ïûê Í¥ÄÎ¶¨, Í≤∞Ï†ú ÏãúÏä§ÌÖú, Í¥ÄÎ¶¨Ïûê ÎåÄÏãúÎ≥¥ÎìúÎ•º Ï†úÍ≥µÌïòÎäî Ï¢ÖÌï©Ï†ÅÏù∏ Ìó¨Ïä§ÏºÄÏñ¥ ÌîåÎû´ÌèºÏûÖÎãàÎã§.

### Í∏∞Ïà† Ïä§ÌÉù
- **Backend**: Spring Boot 3.5.6 + Java 17
- **Database**: MySQL 8.0 + Redis (Session)
- **Security**: Spring Security + JWT
- **Build**: Gradle
- **Deployment**: Docker + Cloud Platform

## Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïä§ÌÇ§Îßà ÏÑ§Í≥Ñ

### 1. ÏÇ¨Ïö©Ïûê Í¥ÄÎ¶¨ ÌÖåÏù¥Î∏î

#### users (ÏÇ¨Ïö©Ïûê)
```sql
CREATE TABLE users (
    user_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    phone_number VARCHAR(20),
    full_name VARCHAR(100) NOT NULL,
    birth_date DATE,
    gender ENUM('MALE', 'FEMALE', 'OTHER'),
    status ENUM('ACTIVE', 'INACTIVE', 'SUSPENDED', 'DELETED') DEFAULT 'ACTIVE',
    email_verified BOOLEAN DEFAULT FALSE,
    phone_verified BOOLEAN DEFAULT FALSE,
    last_login_at TIMESTAMP NULL,
    failed_login_attempts INT DEFAULT 0,
    account_locked_until TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    INDEX idx_email (email),
    INDEX idx_phone_number (phone_number),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
);
```

#### user_profiles (ÏÇ¨Ïö©Ïûê ÌîÑÎ°úÌïÑ)
```sql
CREATE TABLE user_profiles (
    profile_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT NOT NULL,
    emergency_contact_name VARCHAR(100),
    emergency_contact_phone VARCHAR(20),
    medical_history TEXT,
    current_medications TEXT,
    allergies TEXT,
    height_cm DECIMAL(5,2),
    weight_kg DECIMAL(5,2),
    blood_type ENUM('A+', 'A-', 'B+', 'B-', 'AB+', 'AB-', 'O+', 'O-'),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE,
    UNIQUE KEY uk_user_profile (user_id)
);
```

#### user_settings (ÏÇ¨Ïö©Ïûê ÌôòÍ≤ΩÏÑ§Ï†ï)
```sql
CREATE TABLE user_settings (
    setting_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT NOT NULL,
    language_code VARCHAR(10) DEFAULT 'ko',
    timezone VARCHAR(50) DEFAULT 'Asia/Seoul',
    notification_enabled BOOLEAN DEFAULT TRUE,
    email_notifications BOOLEAN DEFAULT TRUE,
    push_notifications BOOLEAN DEFAULT TRUE,
    preferred_input_method ENUM('TOUCH', 'VOICE', 'TEXT') DEFAULT 'TOUCH',
    usage_time_limit_minutes INT DEFAULT 0,
    auto_logout_minutes INT DEFAULT 30,
    theme_preference ENUM('LIGHT', 'DARK', 'AUTO') DEFAULT 'LIGHT',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE,
    UNIQUE KEY uk_user_settings (user_id)
);
```

### 2. Í≤ÄÏÇ¨ Î∞è ÏßÑÎã® ÌÖåÏù¥Î∏î

#### test_categories (Í≤ÄÏÇ¨ Ïπ¥ÌÖåÍ≥†Î¶¨)
```sql
CREATE TABLE test_categories (
    category_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    category_name VARCHAR(100) NOT NULL,
    category_code VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    sort_order INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    INDEX idx_category_code (category_code),
    INDEX idx_is_active (is_active)
);
```

#### test_types (Í≤ÄÏÇ¨ Ïú†Ìòï)
```sql
CREATE TABLE test_types (
    test_type_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    category_id BIGINT NOT NULL,
    test_name VARCHAR(100) NOT NULL,
    test_code VARCHAR(50) NOT NULL UNIQUE,
    description TEXT,
    duration_minutes INT,
    preparation_instructions TEXT,
    normal_range_min DECIMAL(10,4),
    normal_range_max DECIMAL(10,4),
    unit VARCHAR(20),
    is_active BOOLEAN DEFAULT TRUE,
    requires_fasting BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (category_id) REFERENCES test_categories(category_id),
    INDEX idx_test_code (test_code),
    INDEX idx_category_id (category_id),
    INDEX idx_is_active (is_active)
);
```

#### test_sessions (Í≤ÄÏÇ¨ ÏÑ∏ÏÖò)
```sql
CREATE TABLE test_sessions (
    session_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT NOT NULL,
    test_type_id BIGINT NOT NULL,
    session_status ENUM('STARTED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED', 'FAILED') DEFAULT 'STARTED',
    start_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    end_time TIMESTAMP NULL,
    device_info JSON,
    environment_data JSON,
    session_notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (user_id) REFERENCES users(user_id),
    FOREIGN KEY (test_type_id) REFERENCES test_types(test_type_id),
    INDEX idx_user_id (user_id),
    INDEX idx_test_type_id (test_type_id),
    INDEX idx_session_status (session_status),
    INDEX idx_start_time (start_time)
);
```

#### test_results (Í≤ÄÏÇ¨ Í≤∞Í≥º)
```sql
CREATE TABLE test_results (
    result_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    session_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    test_type_id BIGINT NOT NULL,
    raw_data JSON NOT NULL,
    processed_data JSON,
    heart_rate_bpm INT,
    blood_pressure_systolic INT,
    blood_pressure_diastolic INT,
    ecg_data LONGTEXT,
    measurement_values JSON,
    analysis_result JSON,
    risk_level ENUM('LOW', 'MODERATE', 'HIGH', 'CRITICAL') DEFAULT 'LOW',
    confidence_score DECIMAL(5,4),
    abnormal_indicators JSON,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (session_id) REFERENCES test_sessions(session_id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(user_id),
    FOREIGN KEY (test_type_id) REFERENCES test_types(test_type_id),
    INDEX idx_session_id (session_id),
    INDEX idx_user_id (user_id),
    INDEX idx_test_type_id (test_type_id),
    INDEX idx_risk_level (risk_level),
    INDEX idx_created_at (created_at)
);
```

#### test_images (Í≤ÄÏÇ¨ Ïù¥ÎØ∏ÏßÄ)
```sql
CREATE TABLE test_images (
    image_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    result_id BIGINT NOT NULL,
    image_type ENUM('ECG', 'CHART', 'REPORT', 'ORIGINAL') NOT NULL,
    file_name VARCHAR(255) NOT NULL,
    file_path VARCHAR(500) NOT NULL,
    file_size_bytes BIGINT,
    mime_type VARCHAR(100),
    image_metadata JSON,
    is_encrypted BOOLEAN DEFAULT TRUE,
    encryption_key_id VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    FOREIGN KEY (result_id) REFERENCES test_results(result_id) ON DELETE CASCADE,
    INDEX idx_result_id (result_id),
    INDEX idx_image_type (image_type)
);
```

#### diagnoses (ÏßÑÎã®)
```sql
CREATE TABLE diagnoses (
    diagnosis_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    result_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    diagnosis_code VARCHAR(20),
    diagnosis_name VARCHAR(200) NOT NULL,
    diagnosis_description TEXT,
    severity ENUM('MILD', 'MODERATE', 'SEVERE', 'CRITICAL') DEFAULT 'MILD',
    confidence_level DECIMAL(5,4),
    recommended_actions TEXT,
    follow_up_required BOOLEAN DEFAULT FALSE,
    follow_up_days INT,
    created_by VARCHAR(100),
    reviewed_by VARCHAR(100),
    reviewed_at TIMESTAMP NULL,
    is_ai_generated BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (result_id) REFERENCES test_results(result_id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(user_id),
    INDEX idx_result_id (result_id),
    INDEX idx_user_id (user_id),
    INDEX idx_diagnosis_code (diagnosis_code),
    INDEX idx_severity (severity)
);
```

### 3. Í≤∞Ï†ú Í¥ÄÎ¶¨ ÌÖåÏù¥Î∏î

#### payment_plans (Í≤∞Ï†ú ÌîåÎûú)
```sql
CREATE TABLE payment_plans (
    plan_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    plan_name VARCHAR(100) NOT NULL,
    plan_code VARCHAR(50) NOT NULL UNIQUE,
    plan_type ENUM('FREE', 'BASIC', 'PREMIUM', 'PROFESSIONAL') NOT NULL,
    price_amount DECIMAL(10,2) NOT NULL,
    currency_code VARCHAR(3) DEFAULT 'KRW',
    billing_cycle ENUM('DAILY', 'WEEKLY', 'MONTHLY', 'YEARLY') NOT NULL,
    test_limit_per_cycle INT DEFAULT -1,
    features JSON,
    is_active BOOLEAN DEFAULT TRUE,
    trial_days INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    INDEX idx_plan_code (plan_code),
    INDEX idx_plan_type (plan_type),
    INDEX idx_is_active (is_active)
);
```

#### user_subscriptions (ÏÇ¨Ïö©Ïûê Íµ¨ÎèÖ)
```sql
CREATE TABLE user_subscriptions (
    subscription_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT NOT NULL,
    plan_id BIGINT NOT NULL,
    status ENUM('ACTIVE', 'CANCELLED', 'EXPIRED', 'SUSPENDED') DEFAULT 'ACTIVE',
    start_date DATE NOT NULL,
    end_date DATE,
    auto_renewal BOOLEAN DEFAULT TRUE,
    trial_end_date DATE,
    tests_used_this_cycle INT DEFAULT 0,
    cycle_start_date DATE NOT NULL,
    cycle_end_date DATE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (user_id) REFERENCES users(user_id),
    FOREIGN KEY (plan_id) REFERENCES payment_plans(plan_id),
    INDEX idx_user_id (user_id),
    INDEX idx_plan_id (plan_id),
    INDEX idx_status (status),
    INDEX idx_end_date (end_date)
);
```

#### payments (Í≤∞Ï†ú)
```sql
CREATE TABLE payments (
    payment_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id BIGINT NOT NULL,
    subscription_id BIGINT,
    payment_method ENUM('CREDIT_CARD', 'BANK_TRANSFER', 'MOBILE_PAY', 'APPLE_PAY', 'GOOGLE_PAY') NOT NULL,
    payment_provider VARCHAR(100),
    external_payment_id VARCHAR(200),
    amount DECIMAL(10,2) NOT NULL,
    currency_code VARCHAR(3) DEFAULT 'KRW',
    payment_status ENUM('PENDING', 'COMPLETED', 'FAILED', 'CANCELLED', 'REFUNDED') DEFAULT 'PENDING',
    payment_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    invoice_number VARCHAR(100),
    receipt_url VARCHAR(500),
    failure_reason TEXT,
    refund_amount DECIMAL(10,2) DEFAULT 0,
    refund_date TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (user_id) REFERENCES users(user_id),
    FOREIGN KEY (subscription_id) REFERENCES user_subscriptions(subscription_id),
    INDEX idx_user_id (user_id),
    INDEX idx_subscription_id (subscription_id),
    INDEX idx_payment_status (payment_status),
    INDEX idx_payment_date (payment_date),
    INDEX idx_external_payment_id (external_payment_id)
);
```

### 4. Í¥ÄÎ¶¨Ïûê Î∞è ÏãúÏä§ÌÖú ÌÖåÏù¥Î∏î

#### admin_users (Í¥ÄÎ¶¨Ïûê)
```sql
CREATE TABLE admin_users (
    admin_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    full_name VARCHAR(100) NOT NULL,
    role ENUM('SUPER_ADMIN', 'ADMIN', 'MODERATOR', 'VIEWER') NOT NULL,
    permissions JSON,
    is_active BOOLEAN DEFAULT TRUE,
    last_login_at TIMESTAMP NULL,
    created_by BIGINT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (created_by) REFERENCES admin_users(admin_id),
    INDEX idx_username (username),
    INDEX idx_email (email),
    INDEX idx_role (role),
    INDEX idx_is_active (is_active)
);
```

#### system_notifications (ÏãúÏä§ÌÖú ÏïåÎ¶º)
```sql
CREATE TABLE system_notifications (
    notification_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    target_type ENUM('USER', 'ADMIN', 'ALL') NOT NULL,
    target_id BIGINT,
    notification_type ENUM('INFO', 'WARNING', 'ERROR', 'SUCCESS') DEFAULT 'INFO',
    title VARCHAR(200) NOT NULL,
    message TEXT NOT NULL,
    action_url VARCHAR(500),
    is_read BOOLEAN DEFAULT FALSE,
    read_at TIMESTAMP NULL,
    expires_at TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_target_type_id (target_type, target_id),
    INDEX idx_notification_type (notification_type),
    INDEX idx_is_read (is_read),
    INDEX idx_created_at (created_at)
);
```

#### audit_logs (Í∞êÏÇ¨ Î°úÍ∑∏)
```sql
CREATE TABLE audit_logs (
    log_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_type ENUM('USER', 'ADMIN', 'SYSTEM') NOT NULL,
    user_id BIGINT,
    action VARCHAR(100) NOT NULL,
    resource_type VARCHAR(100),
    resource_id BIGINT,
    details JSON,
    ip_address VARCHAR(45),
    user_agent TEXT,
    session_id VARCHAR(100),
    status ENUM('SUCCESS', 'FAILURE', 'ERROR') DEFAULT 'SUCCESS',
    error_message TEXT,
    execution_time_ms INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_user_type_id (user_type, user_id),
    INDEX idx_action (action),
    INDEX idx_resource_type (resource_type),
    INDEX idx_created_at (created_at),
    INDEX idx_status (status)
);
```

### 5. Ïï± Î∞∞Ìè¨ Î∞è Ïö¥ÏòÅ ÌÖåÏù¥Î∏î

#### app_versions (Ïï± Î≤ÑÏ†Ñ)
```sql
CREATE TABLE app_versions (
    version_id BIGINT AUTO_INCREMENT PRIMARY KEY,
    platform ENUM('ANDROID', 'IOS') NOT NULL,
    version_name VARCHAR(20) NOT NULL,
    version_code INT NOT NULL,
    build_number VARCHAR(50),
    release_notes TEXT,
    min_supported_os VARCHAR(20),
    download_url VARCHAR(500),
    file_size_bytes BIGINT,
    checksum VARCHAR(64),
    status ENUM('DEVELOPMENT', 'TESTING', 'APPROVED', 'RELEASED', 'DEPRECATED') DEFAULT 'DEVELOPMENT',
    is_force_update BOOLEAN DEFAULT FALSE,
    rollout_percentage INT DEFAULT 0,
    release_date TIMESTAMP NULL,
    created_by BIGINT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

    FOREIGN KEY (created_by) REFERENCES admin_users(admin_id),
    UNIQUE KEY uk_platform_version (platform, version_name),
    INDEX idx_platform (platform),
    INDEX idx_status (status),
    INDEX idx_release_date (release_date)
);
```

## ÌÅ¥ÎûòÏä§ ÏïÑÌÇ§ÌÖçÏ≤ò ÏÑ§Í≥Ñ

### 1. Entity Classes (JPA Entities)

#### User Entity
```java
@Entity
@Table(name = "users")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Builder
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@ToString(exclude = {"passwordHash", "testSessions", "subscriptions"})
@EqualsAndHashCode(of = "id")
public class User extends BaseTimeEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "user_id")
    private Long id;

    @Column(name = "email", nullable = false, unique = true, length = 100)
    private String email;

    @Column(name = "password_hash", nullable = false)
    private String passwordHash;

    @Column(name = "phone_number", length = 20)
    private String phoneNumber;

    @Column(name = "full_name", nullable = false, length = 100)
    private String fullName;

    @Column(name = "birth_date")
    private LocalDate birthDate;

    @Enumerated(EnumType.STRING)
    @Column(name = "gender")
    private Gender gender;

    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private UserStatus status;

    @Column(name = "email_verified")
    private Boolean emailVerified = false;

    @Column(name = "phone_verified")
    private Boolean phoneVerified = false;

    @Column(name = "last_login_at")
    private LocalDateTime lastLoginAt;

    @Column(name = "failed_login_attempts")
    private Integer failedLoginAttempts = 0;

    @Column(name = "account_locked_until")
    private LocalDateTime accountLockedUntil;

    // Relationships
    @OneToOne(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private UserProfile profile;

    @OneToOne(mappedBy = "user", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private UserSettings settings;

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<TestSession> testSessions = new ArrayList<>();

    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<UserSubscription> subscriptions = new ArrayList<>();

    // Business Methods
    public boolean isActive() {
        return UserStatus.ACTIVE.equals(this.status);
    }

    public boolean isAccountLocked() {
        return accountLockedUntil != null && accountLockedUntil.isAfter(LocalDateTime.now());
    }

    public void lockAccount(Duration duration) {
        this.accountLockedUntil = LocalDateTime.now().plus(duration);
    }

    public void unlockAccount() {
        this.accountLockedUntil = null;
        this.failedLoginAttempts = 0;
    }

    public void incrementFailedLoginAttempts() {
        this.failedLoginAttempts++;
    }

    public void updateLastLogin() {
        this.lastLoginAt = LocalDateTime.now();
        this.failedLoginAttempts = 0;
    }

    public int getAge() {
        if (birthDate == null) return 0;
        return Period.between(birthDate, LocalDate.now()).getYears();
    }
}
```

#### TestResult Entity
```java
@Entity
@Table(name = "test_results")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Builder
@AllArgsConstructor(access = AccessLevel.PRIVATE)
@ToString(exclude = {"rawData", "processedData", "ecgData"})
public class TestResult extends BaseTimeEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "result_id")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "session_id", nullable = false)
    private TestSession session;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "test_type_id", nullable = false)
    private TestType testType;

    @Column(name = "raw_data", columnDefinition = "JSON")
    @Convert(converter = JsonConverter.class)
    private Map<String, Object> rawData;

    @Column(name = "processed_data", columnDefinition = "JSON")
    @Convert(converter = JsonConverter.class)
    private Map<String, Object> processedData;

    @Column(name = "heart_rate_bpm")
    private Integer heartRateBpm;

    @Column(name = "blood_pressure_systolic")
    private Integer bloodPressureSystolic;

    @Column(name = "blood_pressure_diastolic")
    private Integer bloodPressureDiastolic;

    @Lob
    @Column(name = "ecg_data")
    private String ecgData;

    @Column(name = "measurement_values", columnDefinition = "JSON")
    @Convert(converter = JsonConverter.class)
    private Map<String, Double> measurementValues;

    @Column(name = "analysis_result", columnDefinition = "JSON")
    @Convert(converter = JsonConverter.class)
    private AnalysisResult analysisResult;

    @Enumerated(EnumType.STRING)
    @Column(name = "risk_level")
    private RiskLevel riskLevel = RiskLevel.LOW;

    @Column(name = "confidence_score", precision = 5, scale = 4)
    private BigDecimal confidenceScore;

    @Column(name = "abnormal_indicators", columnDefinition = "JSON")
    @Convert(converter = JsonConverter.class)
    private List<String> abnormalIndicators;

    // Relationships
    @OneToMany(mappedBy = "testResult", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<TestImage> images = new ArrayList<>();

    @OneToMany(mappedBy = "testResult", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Diagnosis> diagnoses = new ArrayList<>();

    // Business Methods
    public boolean isAbnormal() {
        return !RiskLevel.LOW.equals(riskLevel) ||
               (abnormalIndicators != null && !abnormalIndicators.isEmpty());
    }

    public boolean requiresImmediateAttention() {
        return RiskLevel.CRITICAL.equals(riskLevel);
    }

    public void addAbnormalIndicator(String indicator) {
        if (abnormalIndicators == null) {
            abnormalIndicators = new ArrayList<>();
        }
        abnormalIndicators.add(indicator);
    }

    public double getConfidencePercentage() {
        return confidenceScore != null ? confidenceScore.doubleValue() * 100 : 0.0;
    }
}
```

### 2. Service Classes

#### UserService
```java
@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
@Slf4j
public class UserService {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final UserProfileService userProfileService;
    private final UserSettingsService userSettingsService;
    private final AuditLogService auditLogService;
    private final NotificationService notificationService;

    @Transactional
    public UserResponseDto createUser(UserCreateDto userCreateDto) {
        validateUserCreation(userCreateDto);

        User user = User.builder()
                .email(userCreateDto.getEmail())
                .passwordHash(passwordEncoder.encode(userCreateDto.getPassword()))
                .fullName(userCreateDto.getFullName())
                .phoneNumber(userCreateDto.getPhoneNumber())
                .birthDate(userCreateDto.getBirthDate())
                .gender(userCreateDto.getGender())
                .status(UserStatus.ACTIVE)
                .emailVerified(false)
                .phoneVerified(false)
                .failedLoginAttempts(0)
                .build();

        User savedUser = userRepository.save(user);

        // Create default profile and settings
        userProfileService.createDefaultProfile(savedUser);
        userSettingsService.createDefaultSettings(savedUser);

        // Send verification email
        notificationService.sendEmailVerification(savedUser);

        // Log user creation
        auditLogService.logUserAction(savedUser.getId(), "USER_CREATED",
                Map.of("email", savedUser.getEmail()));

        log.info("Created new user with ID: {}", savedUser.getId());

        return UserResponseDto.from(savedUser);
    }

    @Transactional
    public UserResponseDto authenticateUser(UserLoginDto loginDto) {
        User user = userRepository.findByEmail(loginDto.getEmail())
                .orElseThrow(() -> new UserNotFoundException("User not found with email: " + loginDto.getEmail()));

        // Check if account is locked
        if (user.isAccountLocked()) {
            throw new AccountLockedException("Account is temporarily locked");
        }

        // Verify password
        if (!passwordEncoder.matches(loginDto.getPassword(), user.getPasswordHash())) {
            handleFailedLogin(user);
            throw new InvalidCredentialsException("Invalid email or password");
        }

        // Check if account is active
        if (!user.isActive()) {
            throw new InactiveAccountException("Account is not active");
        }

        // Update last login
        user.updateLastLogin();
        userRepository.save(user);

        // Log successful login
        auditLogService.logUserAction(user.getId(), "USER_LOGIN",
                Map.of("email", user.getEmail(), "loginTime", LocalDateTime.now()));

        log.info("User authenticated successfully: {}", user.getId());

        return UserResponseDto.from(user);
    }

    private void handleFailedLogin(User user) {
        user.incrementFailedLoginAttempts();

        // Lock account after 5 failed attempts
        if (user.getFailedLoginAttempts() >= 5) {
            user.lockAccount(Duration.ofMinutes(30));
            notificationService.sendAccountLockNotification(user);
            log.warn("Account locked due to failed login attempts: {}", user.getEmail());
        }

        userRepository.save(user);

        auditLogService.logUserAction(user.getId(), "FAILED_LOGIN",
                Map.of("email", user.getEmail(), "attempts", user.getFailedLoginAttempts()));
    }

    private void validateUserCreation(UserCreateDto dto) {
        if (userRepository.existsByEmail(dto.getEmail())) {
            throw new UserAlreadyExistsException("User already exists with email: " + dto.getEmail());
        }

        if (dto.getPhoneNumber() != null && userRepository.existsByPhoneNumber(dto.getPhoneNumber())) {
            throw new UserAlreadyExistsException("User already exists with phone number: " + dto.getPhoneNumber());
        }
    }
}
```

#### TestResultService
```java
@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
@Slf4j
public class TestResultService {

    private final TestResultRepository testResultRepository;
    private final TestSessionRepository testSessionRepository;
    private final HeartDiseaseAnalysisEngine analysisEngine;
    private final TestImageService testImageService;
    private final DiagnosisService diagnosisService;
    private final NotificationService notificationService;
    private final AuditLogService auditLogService;

    @Transactional
    public TestResultResponseDto processTestResult(Long sessionId, TestResultCreateDto createDto) {
        TestSession session = testSessionRepository.findById(sessionId)
                .orElseThrow(() -> new TestSessionNotFoundException("Test session not found: " + sessionId));

        // Validate test data
        validateTestData(createDto);

        // Process raw data through AI analysis engine
        AnalysisResult analysisResult = analysisEngine.analyzeHeartData(createDto.getRawData());

        // Create test result
        TestResult testResult = TestResult.builder()
                .session(session)
                .user(session.getUser())
                .testType(session.getTestType())
                .rawData(createDto.getRawData())
                .processedData(analysisResult.getProcessedData())
                .heartRateBpm(extractHeartRate(createDto.getRawData()))
                .bloodPressureSystolic(extractSystolic(createDto.getRawData()))
                .bloodPressureDiastolic(extractDiastolic(createDto.getRawData()))
                .ecgData(createDto.getEcgData())
                .measurementValues(analysisResult.getMeasurementValues())
                .analysisResult(analysisResult)
                .riskLevel(analysisResult.getRiskLevel())
                .confidenceScore(analysisResult.getConfidenceScore())
                .abnormalIndicators(analysisResult.getAbnormalIndicators())
                .build();

        TestResult savedResult = testResultRepository.save(testResult);

        // Process images if provided
        if (createDto.getImages() != null && !createDto.getImages().isEmpty()) {
            testImageService.processTestImages(savedResult, createDto.getImages());
        }

        // Generate AI diagnosis
        diagnosisService.generateAIDiagnosis(savedResult);

        // Send notifications for abnormal results
        if (savedResult.isAbnormal()) {
            notificationService.sendAbnormalResultNotification(savedResult);
        }

        // Log test result processing
        auditLogService.logUserAction(session.getUser().getId(), "TEST_RESULT_PROCESSED",
                Map.of("resultId", savedResult.getId(), "riskLevel", savedResult.getRiskLevel()));

        log.info("Processed test result for session: {}, risk level: {}",
                sessionId, savedResult.getRiskLevel());

        return TestResultResponseDto.from(savedResult);
    }

    public List<TestResultResponseDto> getUserTestHistory(Long userId, LocalDateTime fromDate, LocalDateTime toDate) {
        List<TestResult> results = testResultRepository.findByUserIdAndCreatedAtBetween(
                userId, fromDate, toDate);

        return results.stream()
                .map(TestResultResponseDto::from)
                .collect(Collectors.toList());
    }

    private void validateTestData(TestResultCreateDto dto) {
        if (dto.getRawData() == null || dto.getRawData().isEmpty()) {
            throw new InvalidTestDataException("Raw test data is required");
        }

        // Validate heart rate data
        if (dto.getRawData().containsKey("heartRate")) {
            Integer heartRate = (Integer) dto.getRawData().get("heartRate");
            if (heartRate < 30 || heartRate > 250) {
                throw new InvalidTestDataException("Heart rate out of valid range: " + heartRate);
            }
        }

        // Validate blood pressure data
        if (dto.getRawData().containsKey("bloodPressure")) {
            Map<String, Integer> bp = (Map<String, Integer>) dto.getRawData().get("bloodPressure");
            if (bp.get("systolic") < 70 || bp.get("systolic") > 200) {
                throw new InvalidTestDataException("Systolic blood pressure out of valid range");
            }
            if (bp.get("diastolic") < 40 || bp.get("diastolic") > 120) {
                throw new InvalidTestDataException("Diastolic blood pressure out of valid range");
            }
        }
    }

    private Integer extractHeartRate(Map<String, Object> rawData) {
        return rawData.containsKey("heartRate") ? (Integer) rawData.get("heartRate") : null;
    }

    private Integer extractSystolic(Map<String, Object> rawData) {
        if (rawData.containsKey("bloodPressure")) {
            Map<String, Integer> bp = (Map<String, Integer>) rawData.get("bloodPressure");
            return bp.get("systolic");
        }
        return null;
    }

    private Integer extractDiastolic(Map<String, Object> rawData) {
        if (rawData.containsKey("bloodPressure")) {
            Map<String, Integer> bp = (Map<String, Integer>) rawData.get("bloodPressure");
            return bp.get("diastolic");
        }
        return null;
    }
}
```

#### PaymentService
```java
@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
@Slf4j
public class PaymentService {

    private final PaymentRepository paymentRepository;
    private final UserSubscriptionRepository subscriptionRepository;
    private final PaymentPlanRepository planRepository;
    private final PaymentGatewayService paymentGatewayService;
    private final NotificationService notificationService;
    private final AuditLogService auditLogService;

    @Transactional
    public PaymentResponseDto processPayment(Long userId, PaymentCreateDto paymentDto) {
        User user = getUserById(userId);
        PaymentPlan plan = planRepository.findById(paymentDto.getPlanId())
                .orElseThrow(() -> new PaymentPlanNotFoundException("Payment plan not found: " + paymentDto.getPlanId()));

        // Create payment record
        Payment payment = Payment.builder()
                .user(user)
                .paymentMethod(paymentDto.getPaymentMethod())
                .paymentProvider(paymentDto.getPaymentProvider())
                .amount(plan.getPriceAmount())
                .currencyCode(plan.getCurrencyCode())
                .paymentStatus(PaymentStatus.PENDING)
                .build();

        Payment savedPayment = paymentRepository.save(payment);

        try {
            // Process payment through external gateway
            PaymentGatewayResponse gatewayResponse = paymentGatewayService.processPayment(
                    PaymentGatewayRequest.builder()
                            .amount(plan.getPriceAmount())
                            .currency(plan.getCurrencyCode())
                            .paymentMethod(paymentDto.getPaymentMethod())
                            .customerInfo(buildCustomerInfo(user))
                            .build()
            );

            // Update payment with gateway response
            savedPayment.setExternalPaymentId(gatewayResponse.getTransactionId());
            savedPayment.setPaymentStatus(gatewayResponse.isSuccessful() ?
                    PaymentStatus.COMPLETED : PaymentStatus.FAILED);
            savedPayment.setReceiptUrl(gatewayResponse.getReceiptUrl());

            if (!gatewayResponse.isSuccessful()) {
                savedPayment.setFailureReason(gatewayResponse.getErrorMessage());
                paymentRepository.save(savedPayment);
                throw new PaymentProcessingException("Payment failed: " + gatewayResponse.getErrorMessage());
            }

            // Create or update subscription
            UserSubscription subscription = createOrUpdateSubscription(user, plan, savedPayment);
            savedPayment.setSubscription(subscription);

            paymentRepository.save(savedPayment);

            // Send confirmation notifications
            notificationService.sendPaymentConfirmation(user, savedPayment);

            // Log successful payment
            auditLogService.logUserAction(userId, "PAYMENT_COMPLETED",
                    Map.of("paymentId", savedPayment.getId(), "amount", savedPayment.getAmount()));

            log.info("Payment processed successfully for user: {}, amount: {}",
                    userId, savedPayment.getAmount());

            return PaymentResponseDto.from(savedPayment);

        } catch (Exception e) {
            // Update payment status to failed
            savedPayment.setPaymentStatus(PaymentStatus.FAILED);
            savedPayment.setFailureReason(e.getMessage());
            paymentRepository.save(savedPayment);

            // Log failed payment
            auditLogService.logUserAction(userId, "PAYMENT_FAILED",
                    Map.of("paymentId", savedPayment.getId(), "error", e.getMessage()));

            log.error("Payment processing failed for user: {}", userId, e);
            throw new PaymentProcessingException("Payment processing failed", e);
        }
    }

    private UserSubscription createOrUpdateSubscription(User user, PaymentPlan plan, Payment payment) {
        Optional<UserSubscription> existingSubscription =
                subscriptionRepository.findActiveSubscriptionByUserId(user.getId());

        UserSubscription subscription;

        if (existingSubscription.isPresent()) {
            // Extend existing subscription
            subscription = existingSubscription.get();
            subscription.extendSubscription(plan);
        } else {
            // Create new subscription
            LocalDate startDate = LocalDate.now();
            LocalDate endDate = calculateEndDate(startDate, plan.getBillingCycle());

            subscription = UserSubscription.builder()
                    .user(user)
                    .plan(plan)
                    .status(SubscriptionStatus.ACTIVE)
                    .startDate(startDate)
                    .endDate(endDate)
                    .autoRenewal(true)
                    .testsUsedThisCycle(0)
                    .cycleStartDate(startDate)
                    .cycleEndDate(endDate)
                    .build();
        }

        return subscriptionRepository.save(subscription);
    }

    private LocalDate calculateEndDate(LocalDate startDate, BillingCycle billingCycle) {
        return switch (billingCycle) {
            case DAILY -> startDate.plusDays(1);
            case WEEKLY -> startDate.plusWeeks(1);
            case MONTHLY -> startDate.plusMonths(1);
            case YEARLY -> startDate.plusYears(1);
        };
    }
}
```

### 3. Controller Classes

#### UserController
```java
@RestController
@RequestMapping("/api/v1/users")
@RequiredArgsConstructor
@Validated
@Slf4j
@Api(tags = "User Management")
public class UserController {

    private final UserService userService;
    private final JwtTokenProvider jwtTokenProvider;

    @PostMapping("/register")
    @ApiOperation(value = "ÏÇ¨Ïö©Ïûê Îì±Î°ù", notes = "ÏÉàÎ°úÏö¥ ÏÇ¨Ïö©ÏûêÎ•º Îì±Î°ùÌï©ÎãàÎã§.")
    public ResponseEntity<ApiResponse<UserResponseDto>> registerUser(
            @Valid @RequestBody UserCreateDto userCreateDto) {

        UserResponseDto userResponse = userService.createUser(userCreateDto);

        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(userResponse, "ÏÇ¨Ïö©ÏûêÍ∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Îì±Î°ùÎêòÏóàÏäµÎãàÎã§."));
    }

    @PostMapping("/login")
    @ApiOperation(value = "ÏÇ¨Ïö©Ïûê Î°úÍ∑∏Ïù∏", notes = "ÏÇ¨Ïö©Ïûê Ïù∏Ï¶ùÏùÑ ÏàòÌñâÌï©ÎãàÎã§.")
    public ResponseEntity<ApiResponse<LoginResponseDto>> login(
            @Valid @RequestBody UserLoginDto loginDto,
            HttpServletRequest request) {

        UserResponseDto userResponse = userService.authenticateUser(loginDto);

        // Generate JWT token
        String accessToken = jwtTokenProvider.generateAccessToken(userResponse.getId());
        String refreshToken = jwtTokenProvider.generateRefreshToken(userResponse.getId());

        LoginResponseDto loginResponse = LoginResponseDto.builder()
                .user(userResponse)
                .accessToken(accessToken)
                .refreshToken(refreshToken)
                .tokenType("Bearer")
                .expiresIn(jwtTokenProvider.getAccessTokenExpiration())
                .build();

        return ResponseEntity.ok(ApiResponse.success(loginResponse, "Î°úÍ∑∏Ïù∏ÎêòÏóàÏäµÎãàÎã§."));
    }

    @GetMapping("/me")
    @PreAuthorize("hasRole('USER')")
    @ApiOperation(value = "ÎÇ¥ Ï†ïÎ≥¥ Ï°∞Ìöå", notes = "ÌòÑÏû¨ ÏÇ¨Ïö©ÏûêÏùò Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.")
    public ResponseEntity<ApiResponse<UserResponseDto>> getCurrentUser(
            Authentication authentication) {

        Long userId = getUserIdFromAuthentication(authentication);
        UserResponseDto userResponse = userService.getUserById(userId);

        return ResponseEntity.ok(ApiResponse.success(userResponse));
    }

    @PutMapping("/me")
    @PreAuthorize("hasRole('USER')")
    @ApiOperation(value = "ÎÇ¥ Ï†ïÎ≥¥ ÏàòÏ†ï", notes = "ÌòÑÏû¨ ÏÇ¨Ïö©ÏûêÏùò Ï†ïÎ≥¥Î•º ÏàòÏ†ïÌï©ÎãàÎã§.")
    public ResponseEntity<ApiResponse<UserResponseDto>> updateCurrentUser(
            @Valid @RequestBody UserUpdateDto updateDto,
            Authentication authentication) {

        Long userId = getUserIdFromAuthentication(authentication);
        UserResponseDto userResponse = userService.updateUser(userId, updateDto);

        return ResponseEntity.ok(ApiResponse.success(userResponse, "ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥Í∞Ä ÏàòÏ†ïÎêòÏóàÏäµÎãàÎã§."));
    }

    @PutMapping("/me/password")
    @PreAuthorize("hasRole('USER')")
    @ApiOperation(value = "ÎπÑÎ∞ÄÎ≤àÌò∏ Î≥ÄÍ≤Ω", notes = "ÌòÑÏû¨ ÏÇ¨Ïö©ÏûêÏùò ÎπÑÎ∞ÄÎ≤àÌò∏Î•º Î≥ÄÍ≤ΩÌï©ÎãàÎã§.")
    public ResponseEntity<ApiResponse<Void>> changePassword(
            @Valid @RequestBody PasswordChangeDto passwordChangeDto,
            Authentication authentication) {

        Long userId = getUserIdFromAuthentication(authentication);
        userService.changePassword(userId, passwordChangeDto);

        return ResponseEntity.ok(ApiResponse.success(null, "ÎπÑÎ∞ÄÎ≤àÌò∏Í∞Ä Î≥ÄÍ≤ΩÎêòÏóàÏäµÎãàÎã§."));
    }

    @DeleteMapping("/me")
    @PreAuthorize("hasRole('USER')")
    @ApiOperation(value = "ÌöåÏõê ÌÉàÌá¥", notes = "ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê Í≥ÑÏ†ïÏùÑ ÏÇ≠Ï†úÌï©ÎãàÎã§.")
    public ResponseEntity<ApiResponse<Void>> deleteCurrentUser(
            @Valid @RequestBody AccountDeleteDto deleteDto,
            Authentication authentication) {

        Long userId = getUserIdFromAuthentication(authentication);
        userService.deleteUser(userId, deleteDto);

        return ResponseEntity.ok(ApiResponse.success(null, "Í≥ÑÏ†ïÏù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§."));
    }

    private Long getUserIdFromAuthentication(Authentication authentication) {
        return ((UserPrincipal) authentication.getPrincipal()).getUserId();
    }
}
```

#### TestResultController
```java
@RestController
@RequestMapping("/api/v1/test-results")
@RequiredArgsConstructor
@Validated
@Slf4j
@Api(tags = "Test Result Management")
public class TestResultController {

    private final TestResultService testResultService;
    private final TestSessionService testSessionService;

    @PostMapping("/sessions/{sessionId}/results")
    @PreAuthorize("hasRole('USER')")
    @ApiOperation(value = "Í≤ÄÏÇ¨ Í≤∞Í≥º Ï†ÄÏû•", notes = "Í≤ÄÏÇ¨ Í≤∞Í≥ºÎ•º Ï†ÄÏû•ÌïòÍ≥† Î∂ÑÏÑùÌï©ÎãàÎã§.")
    public ResponseEntity<ApiResponse<TestResultResponseDto>> createTestResult(
            @PathVariable @Min(1) Long sessionId,
            @Valid @RequestBody TestResultCreateDto createDto,
            Authentication authentication) {

        Long userId = getUserIdFromAuthentication(authentication);

        // Validate session ownership
        testSessionService.validateSessionOwnership(sessionId, userId);

        TestResultResponseDto result = testResultService.processTestResult(sessionId, createDto);

        return ResponseEntity.status(HttpStatus.CREATED)
                .body(ApiResponse.success(result, "Í≤ÄÏÇ¨ Í≤∞Í≥ºÍ∞Ä Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§."));
    }

    @GetMapping("/my-history")
    @PreAuthorize("hasRole('USER')")
    @ApiOperation(value = "ÎÇ¥ Í≤ÄÏÇ¨ Ïù¥Î†•", notes = "ÏÇ¨Ïö©ÏûêÏùò Í≤ÄÏÇ¨ Ïù¥Î†•ÏùÑ Ï°∞ÌöåÌï©ÎãàÎã§.")
    public ResponseEntity<ApiResponse<PageResponse<TestResultResponseDto>>> getMyTestHistory(
            @RequestParam(defaultValue = "0") @Min(0) int page,
            @RequestParam(defaultValue = "20") @Min(1) @Max(100) int size,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime fromDate,
            @RequestParam(required = false) @DateTimeFormat(iso = DateTimeFormat.ISO.DATE_TIME) LocalDateTime toDate,
            @RequestParam(required = false) String testType,
            Authentication authentication) {

        Long userId = getUserIdFromAuthentication(authentication);

        PageResponse<TestResultResponseDto> results = testResultService.getUserTestHistory(
                userId, page, size, fromDate, toDate, testType);

        return ResponseEntity.ok(ApiResponse.success(results));
    }

    @GetMapping("/{resultId}")
    @PreAuthorize("hasRole('USER') or hasRole('ADMIN')")
    @ApiOperation(value = "Í≤ÄÏÇ¨ Í≤∞Í≥º ÏÉÅÏÑ∏", notes = "ÌäπÏ†ï Í≤ÄÏÇ¨ Í≤∞Í≥ºÏùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥Î•º Ï°∞ÌöåÌï©ÎãàÎã§.")
    public ResponseEntity<ApiResponse<TestResultDetailDto>> getTestResultDetail(
            @PathVariable @Min(1) Long resultId,
            Authentication authentication) {

        TestResultDetailDto result = testResultService.getTestResultDetail(resultId);

        // Check ownership for users (admins can view all)
        if (authentication.getAuthorities().stream()
                .noneMatch(authority -> authority.getAuthority().equals("ROLE_ADMIN"))) {
            Long userId = getUserIdFromAuthentication(authentication);
            if (!result.getUserId().equals(userId)) {
                throw new AccessDeniedException("Ï†ëÍ∑º Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§.");
            }
        }

        return ResponseEntity.ok(ApiResponse.success(result));
    }

    @GetMapping("/{resultId}/export")
    @PreAuthorize("hasRole('USER')")
    @ApiOperation(value = "Í≤ÄÏÇ¨ Í≤∞Í≥º ÎÇ¥Î≥¥ÎÇ¥Í∏∞", notes = "Í≤ÄÏÇ¨ Í≤∞Í≥ºÎ•º PDF ÌòïÌÉúÎ°ú ÎÇ¥Î≥¥ÎÉÖÎãàÎã§.")
    public ResponseEntity<Resource> exportTestResult(
            @PathVariable @Min(1) Long resultId,
            @RequestParam(defaultValue = "PDF") ExportFormat format,
            Authentication authentication) {

        Long userId = getUserIdFromAuthentication(authentication);

        ByteArrayResource resource = testResultService.exportTestResult(resultId, userId, format);

        return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION,
                        "attachment; filename=\"test-result-" + resultId + "." + format.getExtension() + "\"")
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .body(resource);
    }

    private Long getUserIdFromAuthentication(Authentication authentication) {
        return ((UserPrincipal) authentication.getPrincipal()).getUserId();
    }
}
```

## Î©îÏÜåÎìú ÏïåÍ≥†Î¶¨Ï¶ò ÏÑ§Í≥Ñ

### 1. Ïã¨Ïû•ÏßàÌôò Î∂ÑÏÑù ÏïåÍ≥†Î¶¨Ï¶ò

#### HeartDiseaseAnalysisEngine - Ïã¨Ïû• Îç∞Ïù¥ÌÑ∞ Ï¢ÖÌï© Î∂ÑÏÑù
**Î™©Ï†Å**: ÏÇ¨Ïö©ÏûêÍ∞Ä ÏûÖÎ†•Ìïú Ïã¨Ïû• Í¥ÄÎ†® Ï∏°Ï†ï Îç∞Ïù¥ÌÑ∞Î•º AI Î∂ÑÏÑùÌïòÏó¨ Ïã¨Ïû•ÏßàÌôò ÏúÑÌóòÎèÑÎ•º ÌèâÍ∞Ä

**Ï≤òÎ¶¨ Îã®Í≥Ñ**:
1. **Îç∞Ïù¥ÌÑ∞ Ï†ÑÏ≤òÎ¶¨ Î∞è Í≤ÄÏ¶ù**
   - ÏõêÏãú Îç∞Ïù¥ÌÑ∞ÏóêÏÑú Ïã¨Î∞ïÏàò, RR Í∞ÑÍ≤©, ECG Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
   - Îç∞Ïù¥ÌÑ∞ ÌíàÏßà Í≤ÄÏÇ¨ (ÎàÑÎùΩÍ∞í, Î≤îÏúÑ Ï¥àÍ≥ºÍ∞í ÌôïÏù∏)
   - Ïù¥ÎèôÌèâÍ∑† ÌïÑÌÑ∞Î°ú ÎÖ∏Ïù¥Ï¶à Ï†úÍ±∞
   - IQR Î∞©Î≤ïÏúºÎ°ú Ïù¥ÏÉÅÏπò ÌÉêÏßÄ Î∞è Ï†úÍ±∞

2. **Ïã¨Î∞ïÏàò Î∂ÑÏÑù**
   - ÌèâÍ∑† Ïã¨Î∞ïÏàò, ÏµúÎåÄ/ÏµúÏÜå Ïã¨Î∞ïÏàò Í≥ÑÏÇ∞
   - Ïã¨Î∞ïÏàò Î≥ÄÏù¥ÎèÑ(HRV) Î∂ÑÏÑù
   - ÏãúÍ∞Ñ ÎèÑÎ©îÏù∏ ÏßÄÌëú Í≥ÑÏÇ∞ (SDNN, RMSSD, pNN50)
   - Ï£ºÌååÏàò ÎèÑÎ©îÏù∏ ÏßÄÌëú Í≥ÑÏÇ∞ (LF, HF, LF/HF ÎπÑÏú®)

3. **ECG Î∂ÑÏÑù (ÏÑ†ÌÉùÏ†Å)**
   - PÌåå, QRS Î≥µÌï©Ï≤¥, TÌåå ÌòïÌÉú Î∂ÑÏÑù
   - QT Í∞ÑÍ≤©, ST Î∂ÑÏ†à Î≥ÄÌôî Í≤ÄÏ∂ú
   - Î∂ÄÏ†ïÎß• Ìå®ÌÑ¥ ÌÉêÏßÄ

4. **ML Î™®Îç∏ ÏßàÎ≥ë ÏòàÏ∏°**
   - Ï∂îÏ∂úÎêú ÌäπÏÑ±Í∞íÎì§ÏùÑ Î≤°ÌÑ∞Î°ú Íµ¨ÏÑ±
   - ÏÇ¨Ï†Ñ ÌõàÎ†®Îêú Í∏∞Í≥ÑÌïôÏäµ Î™®Îç∏Î°ú ÏßàÎ≥ë Î∂ÑÎ•ò
   - Ïã†Î¢∞ÎèÑ Ï†êÏàò Í≥ÑÏÇ∞

5. **ÏúÑÌóòÎèÑ Ï¢ÖÌï© ÌèâÍ∞Ä**
   - Ïã¨Î∞ïÏàò Î∂ÑÏÑù, ECG Î∂ÑÏÑù, ML ÏòàÏ∏° Í≤∞Í≥º ÌÜµÌï©
   - ÏúÑÌóòÎèÑ Î†àÎ≤® Í≤∞Ï†ï (LOW, MODERATE, HIGH, CRITICAL)
   - Ïù¥ÏÉÅ ÏßÄÌëú Î™©Î°ù ÏÉùÏÑ±

### 2. Í≤∞Ï†ú Ï≤òÎ¶¨ ÏïåÍ≥†Î¶¨Ï¶ò

#### PaymentGatewayService - ÏïàÏ†ÑÌïú Í≤∞Ï†ú Ï≤òÎ¶¨
**Î™©Ï†Å**: Îã§ÏñëÌïú Í≤∞Ï†ú ÏàòÎã®ÏùÑ ÌÜµÌïú ÏïàÏ†ÑÌïòÍ≥† Ïã†Î¢∞ÏÑ± ÏûàÎäî Í≤∞Ï†ú Ï≤òÎ¶¨

**Ï≤òÎ¶¨ Îã®Í≥Ñ**:
1. **Í≤∞Ï†ú ÏöîÏ≤≠ Í≤ÄÏ¶ù**
   - Í≤∞Ï†ú Í∏àÏï° Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ (0Î≥¥Îã§ ÌÅ∞ Í∞í, ÌïúÎèÑ ÎÇ¥)
   - Í≤∞Ï†ú Î∞©Î≤ï Î∞è Í≥†Í∞ù Ï†ïÎ≥¥ ÏôÑÏÑ±ÎèÑ ÌôïÏù∏
   - Í≤∞Ï†ú ÌïúÎèÑ Ï¥àÍ≥º Ïó¨Î∂Ä Í≤ÄÏ¶ù

2. **ÎØºÍ∞ê Ï†ïÎ≥¥ ÏïîÌò∏Ìôî**
   - Ïã†Ïö©Ïπ¥Îìú Î≤àÌò∏, CVV Îì± ÎØºÍ∞ê Ï†ïÎ≥¥ AES ÏïîÌò∏Ìôî
   - Í∞Å Í≤∞Ï†úÎßàÎã§ Í≥†Ïú†Ìïú Í±∞Îûò ID ÏÉùÏÑ±
   - ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ Î∞è Î¨¥Í≤∞ÏÑ± Í≤ÄÏ¶ù Ï†ïÎ≥¥ Ï∂îÍ∞Ä

3. **Í≤∞Ï†ú Í≤åÏù¥Ìä∏Ïõ®Ïù¥ Ïó∞Îèô**
   - Í≤∞Ï†ú Î∞©Î≤ïÎ≥Ñ Ï†ÅÏ†àÌïú PGÏÇ¨ API Ìò∏Ï∂ú
   - Ïã†Ïö©Ïπ¥Îìú, ÏùÄÌñâÏù¥Ï≤¥, Î™®Î∞îÏùºÌéòÏù¥, Apple Pay, Google Pay ÏßÄÏõê
   - API Ìò∏Ï∂ú Ïã§Ìå®Ïãú Ïû¨ÏãúÎèÑ Î°úÏßÅ Ï†ÅÏö©

4. **ÏùëÎãµ Ï≤òÎ¶¨ Î∞è Í≤ÄÏ¶ù**
   - PGÏÇ¨ ÏùëÎãµ Îç∞Ïù¥ÌÑ∞ Î¨¥Í≤∞ÏÑ± Í≤ÄÏ¶ù
   - Í≤∞Ï†ú ÏäπÏù∏/Í±∞Î∂Ä ÏÉÅÌÉú ÌôïÏù∏
   - ÏòÅÏàòÏ¶ù URL Î∞è ÏäπÏù∏Î≤àÌò∏ Ï†ÄÏû•

5. **Ïò§Î•ò Ï≤òÎ¶¨ Î∞è Ïû¨ÏãúÎèÑ**
   - ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò, ÌÉÄÏûÑÏïÑÏõÉ Îì± Ïû¨ÏãúÎèÑ Í∞ÄÎä•Ìïú Ïò§Î•ò ÌåêÎ≥Ñ
   - ÏµúÎåÄ 3ÌöåÍπåÏßÄ ÏûêÎèô Ïû¨ÏãúÎèÑ
   - Ïû¨ÏãúÎèÑ Î∂àÍ∞ÄÎä•Ìïú Ïò§Î•òÎäî Ï¶âÏãú Ïã§Ìå® Ï≤òÎ¶¨

### 3. Î≥¥Ïïà ÏïîÌò∏Ìôî ÏïåÍ≥†Î¶¨Ï¶ò

#### EncryptionService - ÏùòÎ£å Îç∞Ïù¥ÌÑ∞ Î≥¥Ìò∏ ÏïîÌò∏Ìôî
**Î™©Ï†Å**: ÏùòÎ£å Í∞úÏù∏Ï†ïÎ≥¥Î•º ÏïàÏ†ÑÌïòÍ≤å ÏïîÌò∏ÌôîÌïòÏó¨ Ï†ÄÏû• Î∞è Ï†ÑÏÜ°

**ÏïîÌò∏Ìôî Í≥ºÏ†ï**:
1. **Îç∞Ïù¥ÌÑ∞ ÏïîÌò∏Ìôî ÌÇ§(DEK) ÏÉùÏÑ±**
   - Í∞Å Îç∞Ïù¥ÌÑ∞ÎßàÎã§ Í≥†Ïú†Ìïú 256ÎπÑÌä∏ AES ÌÇ§ ÏÉùÏÑ±
   - ÏïîÌò∏ÌïôÏ†ÅÏúºÎ°ú ÏïàÏ†ÑÌïú ÎÇúÏàò ÏÉùÏÑ±Í∏∞ ÏÇ¨Ïö©

2. **Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ ÏïîÌò∏Ìôî**
   - AES-GCM ÏïåÍ≥†Î¶¨Ï¶òÏúºÎ°ú ÌèâÎ¨∏ Îç∞Ïù¥ÌÑ∞ ÏïîÌò∏Ìôî
   - 12Î∞îÏù¥Ìä∏ Ï¥àÍ∏∞Ìôî Î≤°ÌÑ∞(IV) Î¨¥ÏûëÏúÑ ÏÉùÏÑ±
   - 128ÎπÑÌä∏ Ïù∏Ï¶ù ÌÉúÍ∑∏Î°ú Î¨¥Í≤∞ÏÑ± Î≥¥Ïû•

3. **ÌÇ§ ÏïîÌò∏Ìôî ÌÇ§(KEK)Î°ú DEK Î≥¥Ìò∏**
   - ÎßàÏä§ÌÑ∞ ÌÇ§Î•º ÏÇ¨Ïö©ÌïòÏó¨ DEK ÏïîÌò∏Ìôî
   - Ïã§Ï†ú ÌôòÍ≤ΩÏóêÏÑúÎäî HSM ÎòêÎäî KMS ÏÇ¨Ïö© Í∂åÏû•

4. **ÏïîÌò∏Ìôî Í≤∞Í≥º Ìå®ÌÇ§Ïßï**
   - ÏïîÌò∏ÌôîÎêú Îç∞Ïù¥ÌÑ∞, ÏïîÌò∏ÌôîÎêú ÌÇ§, IV, ÌÉúÍ∑∏Î•º JSONÏúºÎ°ú Ï°∞Ìï©
   - Base64 Ïù∏ÏΩîÎî©ÏúºÎ°ú ÏïàÏ†ÑÌïú ÌÖçÏä§Ìä∏ ÌòïÌÉúÎ°ú Î≥ÄÌôò

**Î≥µÌò∏Ìôî Í≥ºÏ†ï**:
1. **ÏïîÌò∏Ìôî Îç∞Ïù¥ÌÑ∞ ÌååÏã±**
   - Base64 ÎîîÏΩîÎî© ÌõÑ JSON Íµ¨Ï°∞ Î∂ÑÏÑù
   - ÏïîÌò∏Ìôî Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú

2. **DEK Î≥µÍµ¨**
   - ÎßàÏä§ÌÑ∞ ÌÇ§Î°ú ÏïîÌò∏ÌôîÎêú DEK Î≥µÌò∏Ìôî
   - ÌÇ§ Î¨¥Í≤∞ÏÑ± Í≤ÄÏ¶ù

3. **Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ Î≥µÌò∏Ìôî**
   - Î≥µÍµ¨Îêú DEKÏôÄ IVÎ•º ÏÇ¨Ïö©ÌïòÏó¨ AES-GCM Î≥µÌò∏Ìôî
   - Ïù∏Ï¶ù ÌÉúÍ∑∏Î°ú Îç∞Ïù¥ÌÑ∞ Î¨¥Í≤∞ÏÑ± Í≤ÄÏ¶ù
   - ÏõêÎ≥∏ ÌèâÎ¨∏ Îç∞Ïù¥ÌÑ∞ Î∞òÌôò

**Î≥¥Ïïà ÌäπÏßï**:
- **Îç∞Ïù¥ÌÑ∞Î≥Ñ ÎèÖÎ¶Ω ÏïîÌò∏Ìôî**: Í∞Å Îç∞Ïù¥ÌÑ∞ÎßàÎã§ ÏÑúÎ°ú Îã§Î•∏ ÌÇ§ ÏÇ¨Ïö©
- **Î¨¥Í≤∞ÏÑ± Î≥¥Ïû•**: GCM Î™®ÎìúÏùò Ïù∏Ï¶ù ÌÉúÍ∑∏Î°ú Î≥ÄÏ°∞ ÌÉêÏßÄ
- **ÌÇ§ Î∂ÑÎ¶¨**: Ïã§Ï†ú Îç∞Ïù¥ÌÑ∞ÏôÄ ÏïîÌò∏Ìôî ÌÇ§Î•º Î∂ÑÎ¶¨ Ï†ÄÏû•
- **Ïû¨ÏÇ¨Ïö© Î∞©ÏßÄ**: IVÎ•º ÌÜµÌïú ÎèôÏùº Îç∞Ïù¥ÌÑ∞Ïùò Îã§Î•∏ ÏïîÌò∏Î¨∏ ÏÉùÏÑ±

Ïù¥ ÏÑ§Í≥Ñ Î¨∏ÏÑúÎäî Ïã¨Ïû•ÏßàÌôò Í≤ÄÏÇ¨ ÏãúÏä§ÌÖúÏùò ÌïµÏã¨Ï†ÅÏù∏ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïä§ÌÇ§Îßà, ÌÅ¥ÎûòÏä§ Íµ¨Ï°∞, Í∑∏Î¶¨Í≥† Ï£ºÏöî ÏïåÍ≥†Î¶¨Ï¶òÏùÑ Ìè¨Ìï®ÌïòÍ≥† ÏûàÏäµÎãàÎã§. ÏùòÎ£å Îç∞Ïù¥ÌÑ∞Ïùò ÌäπÏÑ±ÏùÑ Í≥†Î†§Ìïú Î≥¥ÏïàÏÑ±Í≥º ÌôïÏû•ÏÑ±ÏùÑ Ï§ëÏ†êÏúºÎ°ú ÏÑ§Í≥ÑÎêòÏóàÏäµÎãàÎã§.